_****_Курсы по алгоритмам и структурам данных от Computer Science центр_****_

# "Алгоритмы: теория и практика. Методы" 
[этот курс на stepik.org](https://stepik.org/course/217/info)

Решение задач находится в директории methods, каждый модуль - отдельная задача.


## 2.2.a Небольшое число Фибоначчи

Дано целое число 1 ≤ n ≤ 40. Необходимо вычислить n-е число Фибоначчи (напомним, что F₀ = 0, F₁ = 1 и Fₙ = Fₙ₋₁ + Fₙ₋₂ при n ≥ 2).


**Пример входных данных:**

    3

**Пример выходных данных:**

    2


## 2.2.b Последняя цифра большого числа Фибоначчи

Дано число 1 ≤ n ≤ 10<sup>7</sup>, необходимо найти последнюю цифру
n-го числа Фибоначчи.

Как мы помним, числа Фибоначчи растут очень быстро, поэтому при их вычислении нужно быть аккуратным с переполнением. В данной задаче, впрочем, этой проблемы можно избежать, поскольку нас интересует только последняя цифра числа Фибоначчи: если
0 ≤ a, b ≤ 9 — последние цифры чисел F<sub>i</sub> и F<sub>i+1</sub> соответственно, то (a + b)mod10 — последняя цифра числа F<sub>i+2</sub>.


**Пример входных данных:**

    841645

**Пример выходных данных:**

    5


## 2.2.c Огромное число Фибоначчи по модулю

Даны целые числа 1 ≤ n ≤ 10<sup>18</sup> и , 2 ≤ m ≤ 10<sup>5</sup>, необходимо найти остаток от деления n-го числа Фибоначчи на m


**Пример входных данных:**

    10 2

**Пример входных данных:**

    1


## 2.3 Наибольший общий делитель

По данным двум числам 1 ≤ a, b ≤ 2 * 10<sup>9</sup> найдите их наибольший общий делитель.


**Пример входных данных:**

    18 35

**Пример выходных данных:**

    1

**Пример входных данных:**

    14159572 63967072

**Пример выходных данных:**

    4

## 4.1.a Покрыть отрезки точками

По данным n отрезкам необходимо найти множество точек минимального размера, для которого каждый из отрезков содержит хотя бы одну из точек.
В первой строке дано число 1 ≤ n ≤ 100 отрезков. Каждая из последующих 
n строк содержит по два числа 0 ≤ l ≤ r ≤10<sup>9</sup>, задающих начало и конец отрезка. Выведите оптимальное число 
m точек и сами m точек. Если таких множеств точек несколько, выведите любое из них.


**Пример входных данных:**

    3
    1 3
    2 5
    3 6

**Пример выходных данных:**

    1
    3

**Пример входных данных:**

    4
    4 7
    1 3
    2 5
    5 6

**Пример выходных данных:**

    2
    3 6


## 4.1.b Непрерывный рюкзак

Первая строка содержит количество предметов 1 ≤ n ≤ 10<sup>3</sup> и вместимость рюкзака 1 ≤ W ≤ 2 * 10<sup>6</sup>  отрезков. Каждая из следующих n строк задаёт стоимость 0 ≤ с<sub>i</sub> ≤ 2 * 10<sup>6</sup> и объём 0 ≤ w<sub>i</sub> ≤ 2 * 10<sup>6</sup> предмета (n, W, с<sub>i</sub>, w<sub>i</sub> - целые числа). Выведите максимальную стоимость частей предметов (от каждого предмета можно отделить любую часть, стоимость и объём при этом пропорционально уменьшатся), помещающихся в данный рюкзак, с точностью не менее трёх знаков после запятой.


**Пример входных данных:**

    3 50
    60 20
    100 50
    120 30

**Пример выходных данных:**

    180.000


## 4.1.c Различные слагаемые

По данному числу 1 ≤ n ≤10<sup>9</sup> найдите максимальное число 
k, для которого n можно представить как сумму k различных натуральных слагаемых. Выведите в первой строке число k, во второй — k слагаемых.


**Пример входных данных:**

    4

**Пример выходных данных:**

    2
    1 3

**Пример входных данных:**

    6

**Пример выходных данных:**

    3
    1 2 3


## 4.2.a Кодирование Хаффмана

По данной непустой строке s длины не более 10<sup>4</sup>, состоящей из строчных букв латинского алфавита, постройте оптимальный беспрефиксный код. В первой строке выведите количество различных букв 
k, встречающихся в строке, и размер получившейся закодированной строки. В следующих k строках запишите коды букв в формате "letter: code". В последней строке выведите закодированную строку.


**Пример входных данных:**

    a

**Пример выходных данных:**

    1 1
    а: 0
    0

**Пример входных данных:**

    abacabad

**Пример выходных данных:**

    4 14
    a: 0
    b: 10
    c: 110
    d: 111
    01001100100111


## 4.2.b Декодирование Хаффмана

Восстановите строку по её коду и беспрефиксному коду символов. 

В первой строке входного файла заданы два целых числа k и l через пробел — количество различных букв, встречающихся в строке, и размер получившейся закодированной строки, соответственно. В следующих
k строках записаны коды букв в формате "letter: code". Ни один код не является префиксом другого. Буквы могут быть перечислены в любом порядке. В качестве букв могут встречаться лишь строчные буквы латинского алфавита; каждая из этих букв встречается в строке хотя бы один раз. Наконец, в последней строке записана закодированная строка. Исходная строка и коды всех букв непусты. Заданный код таков, что закодированная строка имеет минимальный возможный размер.

В первой строке выходного файла выведите строку s. Она должна состоять из строчных букв латинского алфавита. Гарантируется, что длина правильного ответа не превосходит 10<sup>4</sup> символов.



**Пример входных данных:**

    1 1
    а: 0
    0

**Пример выходных данных:**

    a

**Пример входных данных:**

    4 14
    a: 0
    b: 10
    c: 110
    d: 111
    01001100100111


**Пример выходных данных:**

    abacabad




## 4.3 Очередь с приоритетами

Первая строка входа содержит число операций 1 ≤ n ≤ 10<sup>5</sup>. Каждая из последующих n строк задают операцию одного из следующих двух типов:

* **Insert x**, где  0 ≤ x ≤ 10<sup>9</sup> — целое число;
* **ExtractMax**.

Первая операция добавляет число x в очередь с приоритетами, вторая — извлекает максимальное число и выводит его.


**Пример входных данных:**

    6
    Insert 200
    Insert 10
    ExtractMax
    Insert 5
    Insert 500
    ExtractMax

**Пример выходных данных:**

    200
    500


## 6.1 Двоичный поиск

В первой строке даны целое число 
1 ≤ n ≤ 10<sup>5</sup> и массив A[1...n] из n различных натуральных чисел, не превышающих 
10<sup>9</sup>, в порядке возрастания, во второй — целое число 
1 ≤ k ≤ 10<sup>5</sup> k натуральных чисел 
b<sub>1</sub>,...,b<sub>k</sub>, не превышающих 
10<sup>9</sup>. Для каждого 
i от 1 до k необходимо вывести индекс
1 ≤ j ≤ n, для которого A[j] = b<sub>i</sub>, или  -1 если такого j нет.


**Пример входных данных:**

    5 1 5 8 12 13
    5 8 1 23 1 11

**Пример выходных данных:**

    3 1 -1 1 -1


## 6.4 Сортировка слиянием. Число инверсий

Первая строка содержит число 1 ≤ n ≤ 10<sup>5</sup>, вторая — массив A[1...n] , содержащий натуральные числа, не превосходящие 10<sup>9</sup>. 
Необходимо посчитать число пар индексов 1 ≤ i < j ≤ n для которых A[i] > A[j]. (Такая пара элементов называется инверсией массива. Количество инверсий в массиве является в некотором смысле его мерой неупорядоченности: например, в упорядоченном по неубыванию массиве инверсий нет вообще, а в массиве, упорядоченном по убыванию, инверсию образуют каждые два элемента.)


**Пример входных данных:**

    5
    2 3 9 2 9

**Пример выходных данных:**

    2


## 6.5 Быстрая сортировка

В первой строке задано два целых числа 1 ≤ n ≤ 50000 и 1 ≤ m ≤ 50000 — количество отрезков и точек на прямой, соответственно. Следующие n строк содержат по два целых числа a<sub>i</sub> и b<sub>i</sub> (a<sub>i</sub> ≤ b<sub>i</sub>)  — координаты концов отрезков. Последняя строка содержит m целых чисел — координаты точек. Все координаты не превышают 10<sup>8</sup> по модулю. Точка считается принадлежащей отрезку, если она находится внутри него или на границе. Для каждой точки в порядке появления во вводе выведите, скольким отрезкам она принадлежит.


**Пример входных данных:**

    2 3
    0 5
    7 10
    1 6 11

**Пример выходных данных:**

    1 0 0


## 6.8 Сортировка подсчётом

Первая строка содержит число 1 ≤ n ≤ 10<sup>4</sup>, вторая — n натуральных чисел, не превышающих 10. Выведите упорядоченную по неубыванию последовательность этих чисел.

**Пример входных данных:**

    5
    2 3 9 2 9

**Пример выходных данных:**

    2 2 3 9 9

## 8.2.a Динамическое программирование. Наибольшая последовательнократная подпоследовательность

Дано целое число 1 ≤ n ≤ 10<sup>3</sup> и массив A[1...n] натуральных чисел, не превосходящих 2 * 10<sup>9</sup>.
Выведите максимальное 1 ≤ k ≤ n, для которого найдётся подпоследовательность 1 ≤ i<sub>1</sub> < i<sub>2</sub> < ... < i<sub>k</sub> ≤ n длины k, в которой каждый элемент делится на предыдущий (формально: для всех 1 ≤ j < k, A[i<sub>j</sub>] | A[i<sub>j + 1</sub>]

 , вторая — n натуральных чисел, не превышающих 10. Выведите упорядоченную по неубыванию последовательность этих чисел.

**Пример входных данных:**

    4
    3 6 7 12

**Пример выходных данных:**

    3

## 8.2.b Динамическое программирование. Наибольшая последовательнократная подпоследовательность

Дано целое число 1 ≤ n ≤ 10<sup>5</sup> и массив A[1...n], содержащий неотрицательные целые числа, не превосходящие 10<sup>9</sup>.
Найдите наибольшую невозрастающую подпоследовательность в A. В первой строке выведите её длину k, во второй — её индексы 1 ≤ i<sub>1</sub> < i<sub>2</sub> < ... < i<sub>k</sub> ≤ n (таким образом, A[i<sub>1</sub>] ≥ A[i<sub>2</sub>] ≥ ... ≥ A[i<sub>n</sub>].

**Пример входных данных:**

    5
    5 3 4 4 2

**Пример выходных данных:**

    4
    1 3 4 5 

## 8.3 Динамическое программирование. Расстояние редактирования

Вычислите расстояние редактирования двух данных непустых строк длины не более 10<sup>2</sup>, содержащих строчные буквы латинского алфавита.

**Пример входных данных:**

    ab
    ab

**Пример выходных данных:**

    0

**Пример входных данных:**

    short
    ports

**Пример выходных данных:**

    3

## 8.4 Динамическое программирование. Рюкзак

Первая строка входа содержит целые числа 1 ≤ W ≤ 10<sup>4</sup> и 1 ≤ n ≤ 300  — вместимость рюкзака и число золотых слитков. Следующая строка содержит n целых чисел 0 ≤ w<sub>1</sub>, ..., w<sub>n</sub> ≤ 10<sup>5</sup>, задающих веса слитков. Найдите максимальный вес золота, который можно унести в рюкзаке.

**Пример входных данных:**

    10 3
    1 4 8

**Пример выходных данных:**

    9


# "Алгоритмы: теория и практика. Структуры данных" 
[этот курс на stepik.org](https://stepik.org/course/1547/info)

Условия задач в файле statements.pdf
[Скачать документ](statements.pdf)

Решение в директории structures. Каждый модуль - отдельная задача с одноименным названием из statements.pdf

