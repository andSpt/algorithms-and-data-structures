_****_Курсы по алгоритмам и структурам данных от Computer Science центр_****_

# "Алгоритмы: теория и практика. Методы" 
курс на stepik.org: [https://stepik.org/course/217/info]()

Решение задач находится в директории methods, каждый модуль - отдельная задача.


## 2.2.a Небольшое число Фибоначчи

Дано целое число 1 ≤ n ≤ 40. Необходимо вычислить n-е число Фибоначчи (напомним, что F₀ = 0, F₁ = 1 и Fₙ = Fₙ₋₁ + Fₙ₋₂ при n ≥ 2).

---

**Пример входных данных:**

    3

**Пример выходных данных:**

    2

## 2.2.b Последняя цифра большого числа Фибоначчи

Дано число 1 ≤ n ≤ 10<sup>7</sup>, необходимо найти последнюю цифру
n-го числа Фибоначчи.

Как мы помним, числа Фибоначчи растут очень быстро, поэтому при их вычислении нужно быть аккуратным с переполнением. В данной задаче, впрочем, этой проблемы можно избежать, поскольку нас интересует только последняя цифра числа Фибоначчи: если
0 ≤ a, b ≤ 9 — последние цифры чисел F<sub>i</sub> и F<sub>i+1</sub> соответственно, то (a + b)mod10 — последняя цифра числа F<sub>i+2</sub>.

---

**Пример входных данных:**

    841645

**Пример выходных данных:**

    5

## 2.2.c Огромное число Фибоначчи по модулю

Даны целые числа 1 ≤ n ≤ 10<sup>18</sup> и , 2 ≤ m ≤ 10<sup>5</sup>, необходимо найти остаток от деления n-го числа Фибоначчи на m

---
**Пример входных данных:**

    10 2

**Пример входных данных:**

    1

## 2.3 Наибольший общий делитель

По данным двум числам 1 ≤ a, b ≤ 2 * 10<sup>9</sup> найдите их наибольший общий делитель.

---

**Пример входных данных:**

    18 35

**Пример выходных данных:**

    1

---
**Пример входных данных:**

    14159572 63967072

---

**Пример выходных данных:**

    4

## 4.2.a Кодирование Хаффмана

По данной непустой строке s длины не более 10<sup>4</sup>, состоящей из строчных букв латинского алфавита, постройте оптимальный беспрефиксный код. В первой строке выведите количество различных букв 
k, встречающихся в строке, и размер получившейся закодированной строки. В следующих k строках запишите коды букв в формате "letter: code". В последней строке выведите закодированную строку.

---

**Пример входных данных:**

    a

**Пример выходных данных:**

    1 1
    а: 0
    0

---
**Пример входных данных:**

    abacabad

---

**Пример выходных данных:**

    4 14
    a: 0
    b: 10
    c: 110
    d: 111
    01001100100111

## 4.2.b Декодирование Хаффмана

Восстановите строку по её коду и беспрефиксному коду символов. 

В первой строке входного файла заданы два целых числа k и l через пробел — количество различных букв, встречающихся в строке, и размер получившейся закодированной строки, соответственно. В следующих
k строках записаны коды букв в формате "letter: code". Ни один код не является префиксом другого. Буквы могут быть перечислены в любом порядке. В качестве букв могут встречаться лишь строчные буквы латинского алфавита; каждая из этих букв встречается в строке хотя бы один раз. Наконец, в последней строке записана закодированная строка. Исходная строка и коды всех букв непусты. Заданный код таков, что закодированная строка имеет минимальный возможный размер.

В первой строке выходного файла выведите строку s. Она должна состоять из строчных букв латинского алфавита. Гарантируется, что длина правильного ответа не превосходит 10<sup>4</sup> символов.


---

**Пример входных данных:**

    1 1
    а: 0
    0

**Пример выходных данных:**

    a

---
**Пример входных данных:**

    4 14
    a: 0
    b: 10
    c: 110
    d: 111
    01001100100111

---

**Пример выходных данных:**

    abacabad

## 4.1.a Покрыть отрезки точками

По данным n отрезкам необходимо найти множество точек минимального размера, для которого каждый из отрезков содержит хотя бы одну из точек.
В первой строке дано число 1 ≤ n ≤ 100 отрезков. Каждая из последующих 
n строк содержит по два числа 0 ≤ l ≤ r ≤10<sup>9</sup>, задающих начало и конец отрезка. Выведите оптимальное число 
m точек и сами m точек. Если таких множеств точек несколько, выведите любое из них.


**Пример входных данных:**

    3
    1 3
    2 5
    3 6

**Пример выходных данных:**

    1
    3

**Пример входных данных:**

    4
    4 7
    1 3
    2 5
    5 6

**Пример выходных данных:**

    2
    3 6

## 4.1.b Непрерывный рюкзак

Первая строка содержит количество предметов 1 ≤ n ≤ 10<sup>3</sup> и вместимость рюкзака 1 ≤ W ≤ 2 * 10<sup>6</sup>  отрезков. Каждая из следующих n строк задаёт стоимость 0 ≤ с<sub>i</sub> ≤ 2 * 10<sup>6</sup> и объём 0 ≤ w<sub>i</sub> ≤ 2 * 10<sup>6</sup> предмета (n, W, с<sub>i</sub>, w<sub>i</sub> - целые числа). Выведите максимальную стоимость частей предметов (от каждого предмета можно отделить любую часть, стоимость и объём при этом пропорционально уменьшатся), помещающихся в данный рюкзак, с точностью не менее трёх знаков после запятой.



**Пример входных данных:**

    3 50
    60 20
    100 50
    120 30

**Пример выходных данных:**

    180.000

## 4.1.c Различные слагаемые

По данному числу 1 ≤ n ≤10<sup>9</sup> найдите максимальное число 
k, для которого n можно представить как сумму k различных натуральных слагаемых. Выведите в первой строке число k, во второй — k слагаемых.


**Пример входных данных:**

    4

**Пример выходных данных:**

    2
    1 3

**Пример входных данных:**

    6

**Пример выходных данных:**

    3
    1 2 3

## 4.3 Очередь с приоритетами

1 ≤ n ≤ 10<sup>5</sup>. Каждая из последующих n строк задают операцию одного из следующих двух типов:

* **Insert x**, где  0 ≤ x ≤ 10<sup>9</sup> — целое число;
* **ExtractMax**.

Первая операция добавляет число x в очередь с приоритетами, вторая — извлекает максимальное число и выводит его.

**Пример входных данных:**

    6
    Insert 200
    Insert 10
    ExtractMax
    Insert 5
    Insert 500
    ExtractMax

**Пример выходных данных:**

    200
    500

## 6.1 Двоичный поиск

В первой строке даны целое число 
1 ≤ n ≤ 10<sup>5</sup> и массив A[1...n] из n различных натуральных чисел, не превышающих 
10<sup>9</sup>, в порядке возрастания, во второй — целое число 
1 ≤ k ≤ 10<sup>5</sup> k натуральных чисел 
b<sub>1</sub>,...,b<sub>k</sub>, не превышающих 
10<sup>9</sup>. Для каждого 
i от 1 до k необходимо вывести индекс
1 ≤j ≤ n, для которого A[j] = b<sub>i</sub>, или  -1 если такого j нет.


**Пример входных данных:**

    5 1 5 8 12 13
    5 8 1 23 1 11

**Пример выходных данных:**

    3 1 -1 1 -1


# Курс "Алгоритмы: теория и практика. Структуры данных" 
### https://stepik.org/course/1547/info

### Условия задач в файле statements.pdf
Решение в директории structures. Каждый модуль - отдельная задача с одноименным названием из statements.pdf
